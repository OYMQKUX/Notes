# MySQL

[TOC]

## 基础架构

![架构](https://static001.geekbang.org/resource/image/0d/d9/0d2070e8f84c4801adbfa03bda1f98d9.png)

- Server层：涵盖所有核心功能和内置函数
- 存储层：负责数据存储，其中存储引擎为插件模式，常用的有：InnoDB（默认）、MyISAM、Memory

### 实际语句执行过程分析

1. 连接器

   - 客户端与服务端连接

   - 用户权限获取

   - 维持和管理连接

     连接语句：```mysql -h$ip -P$port -u$user -p```（密码一般不写在命令中，防止泄露）

     完成TCP握手之后开始认证身份，同时获取用户权限（该权限的值会维持到连接结束）

     显示当前所有连接：```show processlist;```

     **由于建立连接过程较为复杂，因此尽量使用长连接；然而长连接带来的另一个问题就是内存占用过大，解决方案有两种**：

     **1.  定期断开长连接，或者执行完一个大查询之后断开连接**

     **2. MySQL5.7以上版本可以执行mysql_reset-connection来重新初始化连接资源，这个过程会释放内存且不需要重连**

2. 查询缓存

   执行查询语句的时候，MySQL会先去缓存中查询是否执行过相同的语句，如果有的话则直接返回结果；**但是最好不要使用这种缓存，因为缓存失效十分频繁，大部分缓存几乎没有作用，只有某些特殊的静态表才适合使用这种缓存；**MySQL也支持按需使用查询缓存，可以用关键字SQL_CACHE指定，如：```select SQL_CACHE * from table;```**另外，MySQL8.0以上将不再支持查询缓存**

3. 分析器

   执行词法分析和语法分析，根据结果执行对应查询逻辑

4. 优化器

   同一个语句有多种执行方法，优化器会对其效率进行优化

5. 执行器

   执行器负责具体的查询执行逻辑。执行操作前，先验证用户是否有操作权限；

   以基本的查询语句为例：

   ```select * from student where id=1;```

   如果id没有索引，执行器会调用存储引擎的获取每一行数据的接口，如果行满足查询条件那么将结果保存下来，直到取完整张表格，最后将结果返回客户端；

   如果id有索引，那么执行过程也类似，只不过执行器调用的是存储引擎另一个按索引取数据的接口；

   **在一些慢查询中，会有一个row_examined字段，这个值代表执行器调用了多少次存储引擎接口，然而不同存储引擎在一个接口中可能不止扫描一行数据，因此row_examined和世纪扫描行数不完全相同。**

# 日志系统

```create table T(ID int primary key, c int);```

```update T set c=c+1 where ID=2;```

这是一条普通的更新语句，执行流程和之前的查询语句基本类似：

1. 连接器连接数据库
2. 分析器分析为更新语句
3. 优化器优化
4. 执行器具体执行
5. 记录日志

与查询语句的不同在于更新语句需要记录日志，而两个日志模块最重要：redo log、binlog

## redo log

在MySQL中，为了数据持久化，所有数据都需要存入磁盘中，日志也一样，但如果每次记入磁盘IO压力过大，因此考虑使用WAL(Write Ahead Logging)技术进行优化。具体来说，以InnoDB为例，当有记录需要更新时，InnoDB会把记录写到redo log中，并更新内存；之后当InnoDB空闲时，将操作记录更新到磁盘。