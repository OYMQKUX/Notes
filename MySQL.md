# MySQL
### [基础架构](#1)
### [日志系统](#2)
<h1 id='1'>基础架构</h1>

![架构](https://static001.geekbang.org/resource/image/0d/d9/0d2070e8f84c4801adbfa03bda1f98d9.png)
<font size=3>Server层涵盖几乎所有核心服务功能以及所有内置函数，所有跨存储引擎的实现都在这一层；</br>存储层负责数据存储，支持多种存储引擎，如InnoDB（默认）、MyISAM、Memory</font>

<font size=6 stroke=2>实际语句执行过程分析</font>
</br><font size=5>1. 连接器</font>
<font size=4>
</br>连接器负责让客户端与服务端连接、获取权限、维持和管理连接，一般命令如下：
</br>`mysql -h$ip -P$port -u$user -p`（密码一般不写在语句中，防止泄露）
</br>TCP握手之后连接器开始认证身份，认证通过后获取用户权限，之后的逻辑都依赖于此时获取的权限
</br>`show processlist;`用于显示目前所有链接结果;
</br>当客户端静止时间过长，连接器就会自动断开连接，这个时间默认是8小时（由wait_timeout配置）
</br>**由于建立连接是一件很麻烦的事，所以尽量考虑使用长连接，然而长连接会带来另一个问题，内存的占用过大，解决方案一般有两种：**
</br>**1. 定期断开长连接，或者执行完一个大的查询之后，断开连接，之后的查询再重连**
</br>**2. MySQL5.7以上版本可以执行mysql_reset_connection来重新初始化连接资源，这个过程不需要好重连，但是会释放内存**
</font>
</br><font size=5>2. 查询缓存</font>
<font size=4>
</br>执行查询语句的时候，MySQL会先去缓存中查询是否执行过相同语句，如果有的话，会直接返回结果；**但是最好不要使用这种缓存，因为缓存失效十分频繁，只有那些静态表才适合使用这种缓存**；MySQL也提供了按需使用查询缓存，以SQL_CACHE指定：
</br>`select SQL_CACHE * from table;`
</br> **另外，MySQL8.0以上的版本不再支持查询缓存**
</font>
</br><font size=5>3. 分析器</font>
<font size=4>
</br>执行词法分析和语法分析，根据结果执行对应查询逻辑
</font>
</br><font size=5>4. 优化器</font>
<font size=4>
</br>同一个查询语句有多种执行方法，优化器会对其进行效率优化
</font>
</br><font size=5>5. 执行器</font>
<font size=4>
</br>执行器负责具体的查询执行逻辑。执行操作前，会先验证执行权限，当有足够权限后正式开始执行具体操作，以最基础的查询语句为例：
</br>`select * from student where id=1;`
</br>如果id没有索引，那么执行器会调用存储引擎的接口依次获取每一行的数据，如果满足的行则保存在结果集中，知道取完整张表格，最后将结果返回客户端；
</br>如果id有索引执行过程也大体类似，只是不是调用取每一行的接口而是调用满足查询条件的下一个的接口，类似于迭代器，这些接口都是存储引擎定义的；
</br>在一些慢查询日志中，会有一个**row_examined**字段，这个值代表执行器调用了多少次存储引擎获取数据行的接口，然而在不同存储引擎中可能出现调用一次接口实际上却不止扫描了一行，**因此row_examined和实际扫描行数不完全给相同**。
</font>
<h2 id='2'>日志系统</h2>
