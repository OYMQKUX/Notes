# MySQL

[TOC]

## 基础架构

![架构](https://static001.geekbang.org/resource/image/0d/d9/0d2070e8f84c4801adbfa03bda1f98d9.png)

- Server层：涵盖所有核心功能和内置函数
- 存储层：负责数据存储，其中存储引擎为插件模式，常用的有：InnoDB（默认）、MyISAM、Memory

### 实际语句执行过程分析

1. 连接器

   - 客户端与服务端连接

   - 用户权限获取

   - 维持和管理连接

     连接语句：```mysql -h$ip -P$port -u$user -p```（密码一般不写在命令中，防止泄露）

     完成TCP握手之后开始认证身份，同时获取用户权限（该权限的值会维持到连接结束）

     显示当前所有连接：```show processlist;```

     **由于建立连接过程较为复杂，因此尽量使用长连接；然而长连接带来的另一个问题就是内存占用过大，解决方案有两种**：

     **1.  定期断开长连接，或者执行完一个大查询之后断开连接**

     **2. MySQL5.7以上版本可以执行mysql_reset-connection来重新初始化连接资源，这个过程会释放内存且不需要重连**

2. 查询缓存

   执行查询语句的时候，MySQL会先去缓存中查询是否执行过相同的语句，如果有的话则直接返回结果；**但是最好不要使用这种缓存，因为缓存失效十分频繁，大部分缓存几乎没有作用，只有某些特殊的静态表才适合使用这种缓存；**MySQL也支持按需使用查询缓存，可以用关键字SQL_CACHE指定，如：```select SQL_CACHE * from table;```**另外，MySQL8.0以上将不再支持查询缓存**

3. 分析器

   执行词法分析和语法分析，根据结果执行对应查询逻辑

4. 优化器

   同一个语句有多种执行方法，优化器会对其效率进行优化

5. 执行器

   执行器负责具体的查询执行逻辑。执行操作前，先验证用户是否有操作权限；

   以基本的查询语句为例：

   ```mysql
select * from student where id=1;
   ```
   如果id没有索引，执行器会调用存储引擎的获取每一行数据的接口，如果行满足查询条件那么将结果保存下来，直到取完整张表格，最后将结果返回客户端；

   如果id有索引，那么执行过程也类似，只不过执行器调用的是存储引擎另一个按索引取数据的接口；
   
   **在一些慢查询中，会有一个row_examined字段，这个值代表执行器调用了多少次存储引擎接口，然而不同存储引擎在一个接口中可能不止扫描一行数据，因此row_examined和世纪扫描行数不完全相同。**

# 日志系统

```create table T(ID int primary key, c int);```

```update T set c=c+1 where ID=2;```

这是一条普通的更新语句，执行流程和之前的查询语句基本类似：

1. 连接器连接数据库
2. 分析器分析为更新语句
3. 优化器优化
4. 执行器具体执行
5. 记录日志

与查询语句的不同在于更新语句需要记录日志，而两个日志模块最重要：redo log、binlog

## redo log

在MySQL中，为了数据持久化，所有数据都需要存入磁盘中，日志也一样，但如果每次记入磁盘IO压力过大，因此考虑使用WAL(Write Ahead Logging)技术进行优化。具体来说，以InnoDB为例，当有记录需要更新时，InnoDB会把记录写到redo log中，并更新内存；之后当InnoDB空闲时，将操作记录更新到磁盘。redo log的大小是固定的，可以配置为一组4个文件，每个文件1GB，当记录超过4GB，那么写入指针指向开通从头开始写，如下图所示：

![图1](https://static001.geekbang.org/resource/image/b0/9c/b075250cad8d9f6c791a52b6a600f69c.jpg)

write pos为写指针的位置，check point为擦除指针的位置，两个指针都向后移动，在check point移动时需要擦除数据同时把数据更新到数据文件。如果write pos和check point之间没有额外空间了，就需要停止更新，执行擦除。有了redo log，InnoDb就可以保证即使数据库异常重启，提交记录也不会丢失，称之为**crash-safe**。

## binlog

redo log是存储层InnoDB引擎的日志，而server层的日志就是binlog。两者有几点不同：

1. redo log是InnoDB引擎特有的，binlog是MySQL中server层实现的，所有引擎都可以使用。
2. redo log是物理日志，记录的是数据的具体修改；而binlog是逻辑日志，记录语句的原始逻辑；
3. redo log固定大小，空间写完要执行擦除；binlog写完一个文件会切到下一个文件

## 过程分析

以之前简单的Update语句为例进行分析：

![过程](https://static001.geekbang.org/resource/image/2e/be/2e5bff4910ec189fe1ee6e2ecc7b4bbe.png)

**浅色为执行器中执行，深色为存储引擎中执行**

1. 执行器首先找到ID=2这一行。
2. 执行器得到值后将值加1，再调用写入接口将结果写回数据库
3. 存储引擎将数据更新到内存
4. 存储引擎将更新操作记录到redo log里面，此时redo log处于prepare，告知执行器随时可以提交事务
5. 执行器生成这次操作的binlog，将binlog写入磁盘
6. 执行器调用引擎的提交事务接口，引擎将redo log改成commit状态

## 两阶段提交

可以看到，整个更新过程redo log日志是两阶段提交，首先置为prepare状态，最后在提交事务的时候变为commit状态。这是为了保证两份日志之间的逻辑一致，而如果不这么做会产生一些问题：

1. 先写redo log再写binlog。假设redo log先写完，而binlog还没有写完，MySQL进程异常重启。重启之后，redo log能把数据恢复，此时数据库不会有问题。但是如果当你需要通过binlog来恢复数据库的时候，由于binlog没有记录到这次操作，那么恢复出来的数据就是有问题的。
2. 先写binlog再写redo log。假设binlog写完，而redo log还没写，MySQL进程异常重启。重启之后，崩溃前的事务执行无效，因此update操作没有成功，但是binlog已经记录下了这次没成功的操作，之后恢复出来的数据同样有问题。

## Tips

**innodb_flush_log_at_trx_commit**这个参数设为1的时候代表每次redo log都直接持久化到硬盘，建议设置，保证每次异常重启后数据不丢失；

**sync_binlog**这个参数设为1的时候代表每次binlog都持久化到硬盘，建议设置，保证异常重启后binlog不丢失

# 事务隔离

事务保证一组操作要么全部成功，要么全部失败。在MySQL中，事务是引擎层实现的，**原生的MyISAM不支持事务操作**。

## 隔离性和隔离级别

当数据库中有多个事务同时执行的时候，可能会出现出现一些问题：

- 脏读（dirty read）：当事务A做了数据更新后，事务B读取到了事务A尚未提交的更新结果，之后事务A回滚，那么事务B之前读到的就是脏数据；
- 不可重复度（nonrepeated read）：事务A在事务B更新操作前后读取到的数据可能不同；
- 幻读（phantom read）：事务A尚未提交前，事务B插入了新的数据，事务A再次读取到的数据和之前不同；

为了解决这些问题，就出现了**隔离级别**这个概念；显然，隔离级别越高，数据库的效率就会越低；SQL标准的事务隔离级别有四种：

- 读未提交：当一个事务未提交时，它做的变更就能被其他事务看到；
- 读提交：一个事物提交之后，它做的变更才能被其他事务看到；
- 可重复读：一个事物执行过程中看到的数据总是和事务启动时看到的一样
- 串行化：对于同一行数据，读会加读锁，写会加写锁，当读写锁出现冲突的时候，后访问的事物必须等前一个事物执行完成才能继续执行

```create table T(c int) engine=InnoDB;```

```insert into T(c) values(1);```

|         事务A         |    事务B    |
| :-------------------: | :---------: |
| 启动事务，查询得到值1 |  启动事务   |
|                       | 查询得到值1 |
|                       |  将1改为2   |
|     查询得到值V1      |             |
|                       |  提交事务B  |
|     查询得到值V2      |             |
|       提交事务A       |             |
|     查询得到值V3      |             |

在不同隔离级别下，得到的值会有区别：

- 读未提交：V1=2，V2=2，V3=2
- 读提交：V1=1，V2=2，V3=2
- 可重复读：V1=1，V2=1，V3=2
- 串行化：V1=1，V2=2，V3=3

在实现上，数据库里面会创建一个视图，访问时候都以视图的结果为准。

- 可重复读：视图在事务启动时创建，整个事务存在期间都用这个视图。
- 读提交：视图在SQL语句执行时创建。
- 读未提交：直接使用数据库上的值，没有视图概念
- 串行化：加锁避免并行访问。

**Oracle**数据库的默认隔离级别是读提交，对于从**Oracle**迁移到**MySQL**上的应用，为了保证隔离级别一致，要将**MySQL**的隔离级别也设置为读提交，具体配置方式如下：

```mysql
show variables like 'transaction_isolation';
```

## 事务隔离的实现

在MySQL中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚，都可以得到前一个状态值。

![回滚](https://static001.geekbang.org/resource/image/d9/ee/d9c313809e5ac148fc39feff532f0fee.png)

不同时刻启动的事务会有不同的read-view。在视图A、B、C里，记录的值应该分别是1、2、4，同一条记录在系统中可以存在多个版本，这就是数据库的多版本并发控制（MVCC）。以read-view A为例，要得到1这个值需要将当前值根据回滚记录依次回滚。当访问的数据库里面没有比这一段回滚记录更早的read-view时，这一段回滚记录就会被删除。**这也是不要使用长事务的原因之一，长事务会导致系统里存在很老的事务视图，在这些事务提交前，回滚记录都不能删除，这就导致占用空间越来越大。另外，长事务还会导致锁资源无法释放**

## 事务的启动方式

MySQL的事务启动方式有两种：

1. 显示启动事务，begin或start transaction。提交语句是commit，回滚语句是rollback。
2. set autocommit=0，这个命令会将这个线程的自动提交关闭。这意味着你执行任意一个SQL语句，事务就启动了，而且不会自动提交，除非主动执行commit或rollback语句，或者断开连接。

有些客户端会在连接成功之后默认执行set autocommit=0命令，这样就可能导致意外的长事务；因此最好都使用set autocommit=1。

而每次主动执行begin和commit会增加语句交互次数，那么在autocommit为1的时候，可以执行commit work and chain，该语句会提交事务并自动启动下一个事务，这样省去了多一次begin的开销，并且能明确知道哪些语句属于哪次事务。

想要查询长事务可以使用information_schema库的innodb_trx表，例如：

```mysql
select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(), trx_started))>60;
```

# 索引

索引的出现是为了解决SQL查询慢的问题，提高查询效率，类似于给书本加一个目录。

## 索引的常见模型

### 哈希表

哈希表是一种key-value存储数据的结构，通过一系列运算将key变为一个值后将其存储在数组固定位置，查找起来也很方便，直接对查找key经过同样的运算，找到存储数据的位置，取出value。哈希表的一个问题是，不同key经过相同运算后得到的值有可能是相同的，处理这种情况的一种方法是，存储value的位置从一个单独空间变为一整个链表。

以下图身份证号为key，名字为value为例：

## ![img](https://static001.geekbang.org/resource/image/0c/57/0c62b601afda86fe5d0fe57346ace957.png)

可以看出，ID_card_n2和ID_card_n4经过运算后的值都是N，因此为了查找ID_card_n2对应的值，需要先找到N，然后从链表头开始依次向后查找。然而哈希表另一个更大的问题是，无法做范围查询，从图中可以看出来，身份证号经过运算后的值不是单调的，这样做范围查询的话只能全部遍历一遍。因此，**哈希表只适用于做等值查询**，例如Memcached及一些NoSQL引擎。

### 有序数组

有序数组无论等值查询还是范围查询的复杂度都很低，还是以身份证号-名字为例：

![img](https://static001.geekbang.org/resource/image/bf/49/bfc907a92f99cadf5493cf0afac9ca49.png)

- 在做等值查询时可以使用二分法，复杂度为O(log(n))
- 在做范围查询时也是二分法找到左边界，依次向右遍历，复杂度为O(log(n) + k)

然而有序数组的问题是，更新数据太过复杂，如果想向中间插入或者删除一个数，那么就要移动之后的所有数据；因此，**有序数组只适用于静态存储引擎**，即数据库基本不会有更新。

### 二叉搜索树

![img](https://static001.geekbang.org/resource/image/04/68/04fb9d24065635a6a637c25ba9ddde68.png)

二叉搜索树的特点是左节点大于右节点，复杂度分别是：

- 等值查询：O(log(n))
- 更新：O(log(n))（为了保证树的平衡）
- 范围查询：O(log(n))

二叉树所有时间复杂度都很优秀，然而大多数数据库的存储却不使用它，原因是我们要查询的数据不一定在内存中，还有可能在硬盘上，例如，我们有一颗高度为20的二叉树，最坏情况需要遍历20个节点才能找到数据，也就是说我们需要最多访问此硬盘，而机械硬盘读取一个数据块的时间是10ms左右，因此这次查询需要至多200ms的时间。

### 多叉树

多叉树每个节点可以不止存储一个数据，InnoDb一个节点差不多存储1200个数，以高度为20的二叉树为例，使用多叉树高度为2~3，访问硬盘的次数也就是2~3次，查询速度大大增加，再加上树的第二层很有可能在内存中，那么访问硬盘次数就更少了。

### 其他

LSM树，跳表等。

## 实例分析

在MySQL中，索引是在存储引擎中实现的，因此没有统一标准，这里以InnoDB为例，每一个索引在InnoDB中都是一棵B+树。

先建一个以ID为主键，字段k上有索引的表：

```mysql
create table T(
	ID int primary key,
	k int not null,
	name varchar(16),
	index k(k)
) engine=InnoDB;
```

![img](https://static001.geekbang.org/resource/image/dc/8d/dcda101051f28502bd5c4402b292e38d.png)

索引分为主键索引和非主键索引：

- 主键索引的叶子节点存的是整行数据，主键索引也称为聚簇索引（clustered index)。
- 非主键索引的叶子节点存的是主键的值，非主键索引也称为二级索引（secondary index）。

以一个查询语句为例说明区别：

- ```select * from T where ID=500;```只搜索主键B+树；
- ```select * from T where k=5```先搜索k索引B+树，得到主键的值后再搜索主键B+树，得到数据行。这个过程称为回表；

可以看出，非主键查询多了一次回表，因此尽量使用主键查询。

## 索引维护

B+树为了维护索引的有序，在插入值的时候需要做维护。以上图为例，如果需要插入新的行ID为700，那么就要在R5之后加入一个新的记录；然而如果新的行ID为400，那么就要挪动后面的数据，空出一个位置。更复杂的情况是，如果R5所在的数据页已经满了，那么根据B+树的算法，就需要申请一个新的数据页，然后挪动部分数据，这个过程称之为叶分裂；这种情况下，不仅性能受到影响，空间利用率也会下降大约50%。

## 自增主键

基于索引维护过程，引入一个自增主键的概念，在一些建表规范里面会特别提到这个规范。自增主键的定义语句为```NOT NULL PRIMARY KEY AUTO_INCREMENT```。

在插入新的值的时候，可以不指定主键的值，系统会获取当前ID最大值，自动加一作为新数据的主键。这样插入的数据保证主键从小到大依次插入，不会触发之前说的数据挪动和叶分裂等问题。除了性能方面，从存储空间方面来看，也是自增主键优势大一些。以身份证号-名字为例，非主键B+树上记录的值为主键的值，如果以身份证号为主键，那么需要18个字节；而如果使用自增主键，那么只需要4个字节（整型，长整型为8个字节）。**因此，主键长度越小，普通索引B+树的叶子节点占用空间就越小。**

当然，只有一个索引，且该索引必须作为唯一索引就应该使用该字段作为索引。因为这种情况不存在普通索引B+树，而且性能上能防止多一次回表查询。

## 覆盖索引

```mysql
create table T(
	ID int primary key,
	k int NOT NULL DEFAULT 0,
	s varchar(16) NOT NULL DEFAULT '',
	index k(k)
)engine=InnoDB;
insert into T values(100, 1, 'aa'), (200, 2, 'bb'),
(300, 3, 'cc'), (500, 5, 'ee'), (600, 6, 'ff'), 
(700, 7, 'gg');
```

以以上建表为例，如果我们需要查询k为3~5的数据行，即：

```mysql
select * from T where k between 3 and 5;
```

具体执行过程如下：

1. 在k索引树上找到k=3的记录，取到主键ID=300；
2. 再去ID索引树上找到ID=300对应的数据；
3. 再去k索引树找到k=5的记录，取到主键ID=500；
4. 再去ID索引树找到ID=500对应的数据；
5. 再去k索引树上找到k=6的记录，没有记录，循环结束；

这个过程显然比较繁琐，实际可以进行优化。

如果我们的查询语句改成：

```mysql
select ID from T where k between 3 and 5;
```

那么就不需要再去主索引树上进行回表查询，此时k就称为这种需求的覆盖索引。覆盖索引其实就是一种特殊的联合索引。

## 最左前缀原则

索引能够加快数据查询速度，但是如果每种查询情况都要额外引入索引，那么索引就太多了，因此需要做一定的设计考量。**B+树的索引结构，可以利用该索引的最左前缀来定位数据位置。**

![img](https://static001.geekbang.org/resource/image/89/70/89f74c631110cfbc83298ef27dcd6370.jpg)

以上图为例，联合索引是有顺序的，例如查询名字为张三的人，B+树可以快速定位到第一个符合的结果ID4；甚至要查询姓张的人，也可以快速定位；

基于这个原则，建立联合索引的时候需要安排好索引的顺序，**基本原则是尽量少的建立额外索引**，例如建立了联合索引(a,b)就不需要再额外建立索引b了，但是如果需要基于b做查询，那么还是需要另外增加一个索引b，这时候的考虑原则就是空间大小，如果a比b占用的空间小，就应该建立(b, a)索引和a索引。

## 索引下推

```mysql
CREATE TABLE `tuser` (
  `id` int(11) NOT NULL,
  `id_card` varchar(32) DEFAULT NULL,
  `name` varchar(32) DEFAULT NULL,
  `age` int(11) DEFAULT NULL,
  `ismale` tinyint(1) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `id_card` (`id_card`),
  KEY `name_age` (`name`,`age`)
) ENGINE=InnoDB
```

以上表为例，考虑以下查询：

```mysql
select * from tuser where name like '张%' and age=10 and ismale=1;
```

根据索引原则，可以很快找到第一个条件，姓为张，之后再一个个回表，找到对应数据行进行值的比对，在MySQL5.6之前的做法是这样。但是在MySQL5.6之后，引入了索引下推优化（index condition pushdown），可以在索引遍历过程中，对索引中包含的字段先做判断，过滤掉一些条件，减少回表次数，区别如下图所示：

![img](https://static001.geekbang.org/resource/image/b3/ac/b32aa8b1f75611e0759e52f5915539ac.jpg)![img](https://static001.geekbang.org/resource/image/76/1b/76e385f3df5a694cc4238c7b65acfe1b.jpg)

第一张图表示，InnoDB只关注符合name的所有结果，再一个个回表查询；

第二张图则是先过滤掉age不满足条件的结果，再回表查询，效率提高了；

# 锁

由于数据库是多用户共享的资源，那么当出现并发访问的时候，数据库就需要锁来合理控制资源的访问。根据加锁的范围，MySQL中的锁大致可以分为**全局锁、表级锁和行锁**。

## 全局锁

全局锁就是对数据库实例加锁，MySQL命令为**Flush tables with read lock(FTWRL)**。这个命令可以让整个数据库处于只读状态，之后数据更新语句、数据定义语句和更新类事务的提交语句都会被阻塞。

全局锁的典型使用场景就是**全库逻辑备份**，即把表里的所有数据取出来存成文本。但是让整个数据库都只读，存在一定风险：

- 给主库加全局锁，整个业务都得暂停
- 给从库加全局锁，主库同步过来的binlog无法执行，导致主从延迟

但是，如果在备份的时候不加锁，会出现更加严重的问题，以用户购买课程为例：

![img](https://static001.geekbang.org/resource/image/cb/cd/cbfd4a0bbb1210792064bcea4e49b0cd.png)

如果在备份期间，发生了购买事务，那么可能导致数据不能正确备份，以上图为例，先备份u.account表，此时账户中还有200块钱，发生购买事务后，备份u.course，此时备份了用户新购买的课程，但是，账户中的钱的备份却没有扣除。

结合之前讲的事务隔离原则，这里出现的问题就是前后的视图不一致，因此如果所有事物都启用RR隔离级别，那么就不会出现备份数据不一致的问题。官方自带的逻辑备份工具是mysqldump，当mysqldump使用参数-single-transaction的时候，导数据之前就会启动一个事务，确保视图的一致性，而且此时不会阻塞数据库的读写。

之所以要引入FTWRL，是因为有些存储引擎不支持RR隔离级别。比如MyISAM就不支持事务，那么就需要使用FTWRL命令。因此，single-transaction只适用于所有表都使用支持事务引擎的库。

当然，数据库还能用另一个命令```set global readonly=true```的方式来让全库只读，但是一般不会这么做，原因有两个：

1. readonly会被用来作为其他逻辑的标志，比如标记一个库是主库还是从库
2. 如果客户端发生异常导致断开，执行FTWRL会自动释放全局锁，然而设置为readonly的话，数据库将一直保持readonly状态，这是十分危险的。

## 表级锁

表级锁有两种，一种是表锁，一种是元数据锁（meta data lock, MDL）。

### 表锁

语法是：```lock tables ... read/write```。与FTWRL类似，可以使用unlock tables主动释放锁，客户端断开的时候也会自动释放。**有一个问题值得注意，lock tables不仅会限制其他线程的读写，对加锁的本线程也会有一定的限制。**例如：

线程A执行```lock tables t1 read, t2 write;```后，其他线程不能写t1，也不能读写t2；**同时，本线程也只能执行读t1，读写t2。**

表锁的影响依然很大，一般不会使用。

### 元数据锁

元数据锁不需要显示使用，在访问一个表的时候会自动加上。元数据锁的作用是保证读写的正确性。

